diff --git a/drivers/gpu/drm/rockchip/rockchip_drm_vop2.c b/drivers/gpu/drm/rockchip/rockchip_drm_vop2.c
index c68d76b25080..9c791268401b 100644
--- a/drivers/gpu/drm/rockchip/rockchip_drm_vop2.c
+++ b/drivers/gpu/drm/rockchip/rockchip_drm_vop2.c
@@ -218,6 +218,7 @@ struct vop2 {
 	struct clk *pclk;
 	// [CC:] hack to support additional display modes
 	struct clk *hdmi0_phy_pll;
+	struct clk *hdmi1_phy_pll;
 	/* list_head of internal clk */
 	struct list_head clk_list_head;
 
@@ -1753,15 +1754,24 @@ static unsigned long rk3588_calc_cru_cfg(struct vop2_video_port *vp, int id,
 	int K = 1;
 
 	if (vop2_output_if_is_hdmi(id)) {
-		if (vop2->data->soc_id == 3588 && id == ROCKCHIP_VOP2_EP_HDMI0 &&
-		    vop2->hdmi0_phy_pll) {
-			const char *clk_src_name = "hdmi_edp0_clk_src";
-			const char *clk_parent_name = "dclk";
-			const char *pixclk_name = "hdmi_edp0_pixclk";
-			const char *dclk_name = "hdmi_edp0_dclk";
+		if (vop2->data->soc_id == 3588 &&
+		    ((id == ROCKCHIP_VOP2_EP_HDMI0 && vop2->hdmi0_phy_pll) ||
+		     (id == ROCKCHIP_VOP2_EP_HDMI1 && vop2->hdmi1_phy_pll))) {
 			struct vop2_clk *if_clk_src, *if_clk_parent, *if_pixclk, *if_dclk, *dclk, *dclk_core, *dclk_out;
+			const char *clk_src_name, *clk_parent_name, *pixclk_name, *dclk_name;
 			char clk_name[32];
 			int ret;
+			clk_parent_name = "dclk";
+
+			if (id == ROCKCHIP_VOP2_EP_HDMI0) {
+				clk_src_name = "hdmi_edp0_clk_src";
+				pixclk_name = "hdmi_edp0_pixclk";
+				dclk_name = "hdmi_edp0_dclk";
+			} else {
+				clk_src_name = "hdmi_edp1_clk_src";
+				pixclk_name = "hdmi_edp1_pixclk";
+				dclk_name = "hdmi_edp1_dclk";
+			}
 
 			if_clk_src = vop2_clk_get(vop2, clk_src_name);
 			snprintf(clk_name, sizeof(clk_name), "%s%d", clk_parent_name, vp->id);
@@ -2242,6 +2252,17 @@ static void vop2_crtc_atomic_enable(struct drm_crtc *crtc,
 							 __clk_get_name(vp->dclk));
 				}
 
+				clock = dclk->rate;
+			} else if (rkencoder->crtc_endpoint_id == ROCKCHIP_VOP2_EP_HDMI1) {
+				clk_get_rate(vop2->hdmi1_phy_pll);
+
+				if (mode->crtc_clock <= VOP2_MAX_DCLK_RATE) {
+					ret = clk_set_parent(vp->dclk, vop2->hdmi1_phy_pll);
+					if (ret < 0)
+						DRM_WARN("failed to set clock parent for %s\n",
+							 __clk_get_name(vp->dclk));
+				}
+
 				clock = dclk->rate;
 			}
 		}
@@ -3630,7 +3651,7 @@ static int vop2_clk_init(struct vop2 *vop2)
 
 	INIT_LIST_HEAD(&vop2->clk_list_head);
 
-	if (vop2->data->soc_id < 3588 || vop2->hdmi0_phy_pll == NULL)
+	if (vop2->data->soc_id < 3588 || vop2->hdmi0_phy_pll == NULL || vop2->hdmi1_phy_pll == NULL)
 		return 0;
 
 	list_for_each_entry_safe(clk, n, &vop2->clk_list_head, list) {
@@ -3745,6 +3766,12 @@ static int vop2_bind(struct device *dev, struct device *master, void *data)
 		return PTR_ERR(vop2->hdmi0_phy_pll);
 	}
 
+	vop2->hdmi1_phy_pll = devm_clk_get_optional(vop2->drm->dev, "hdmi1_phy_pll");
+	if (IS_ERR(vop2->hdmi1_phy_pll)) {
+		DRM_DEV_ERROR(vop2->dev, "failed to get hdmi1_phy_pll source\n");
+		return PTR_ERR(vop2->hdmi1_phy_pll);
+	}
+
 	vop2->irq = platform_get_irq(pdev, 0);
 	if (vop2->irq < 0) {
 		drm_err(vop2->drm, "cannot find irq for vop2\n");
